using System;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

namespace DEM.Net.Core.Stac
{

    // <auto-generated by https://app.quicktype.io
    public partial class CollectionItems
    {
        [JsonProperty("type")]
        public string Type { get; set; }

        [JsonProperty("timeStamp")]
        public DateTimeOffset TimeStamp { get; set; }

        [JsonProperty("features")]
        public List<Feature> Features { get; set; }

        [JsonProperty("links")]
        public List<Link> Links { get; set; }
    }

    public partial class Feature
    {
        [JsonProperty("id")]
        public string Id { get; set; }

        [JsonProperty("collection")]
        public Collection Collection { get; set; }

        [JsonProperty("type")]
        public FeatureType Type { get; set; }

        [JsonProperty("stac_version")]
        public StacVersion StacVersion { get; set; }

        [JsonProperty("geometry")]
        public Geometry Geometry { get; set; }

        [JsonProperty("bbox")]
        public List<float> Bbox { get; set; }

        [JsonProperty("properties")]
        public Properties Properties { get; set; }

        [JsonProperty("links")]
        public List<Link> Links { get; set; }

        [JsonProperty("assets")]
        public Dictionary<string, Asset> Assets { get; set; }
    }

    public partial class Asset
    {
        [JsonProperty("type")]
        public AssetType Type { get; set; }

        [JsonProperty("href")]
        public Uri Href { get; set; }

        [JsonProperty("created")]
        public DateTimeOffset Created { get; set; }

        [JsonProperty("updated")]
        public DateTimeOffset Updated { get; set; }

        [JsonProperty("eo:gsd")]
        public double EoGsd { get; set; }

        [JsonProperty("proj:epsg")]
        public long ProjEpsg { get; set; }

        [JsonProperty("checksum:multihash")]
        public string ChecksumMultihash { get; set; }
    }

    public partial class Geometry
    {
        [JsonProperty("type")]
        public GeometryType Type { get; set; }

        [JsonProperty("coordinates")]
        public List<List<List<double>>> Coordinates { get; set; }
    }

    public partial class Link
    {
        [JsonProperty("rel")]
        public Rel Rel { get; set; }

        [JsonProperty("href")]
        public Uri Href { get; set; }
    }

    public partial class Properties
    {
        [JsonProperty("datetime")]
        public DateTimeOffset Datetime { get; set; }

        [JsonProperty("created")]
        public DateTimeOffset Created { get; set; }

        [JsonProperty("updated")]
        public DateTimeOffset Updated { get; set; }
    }

    public enum AssetType { ApplicationXAsciiXyzZip, ImageTiffApplicationGeotiffProfileCloudOptimized };

    public enum Collection { ChSwisstopoSwissalti3D };

    public enum GeometryType { Polygon };

    public enum Rel { Collection, Next, Parent, Root, Self,
        Previous
    }
    public enum StacVersion { The090 };

    public enum FeatureType { Feature };

    public partial class CollectionItems
    {
        public static CollectionItems FromJson(string json) => JsonConvert.DeserializeObject<CollectionItems>(json, Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this CollectionItems self) => JsonConvert.SerializeObject(self, Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                AssetTypeConverter.Singleton,
                CollectionConverter.Singleton,
                GeometryTypeConverter.Singleton,
                RelConverter.Singleton,
                StacVersionConverter.Singleton,
                FeatureTypeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class AssetTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AssetType) || t == typeof(AssetType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "application/x.ascii-xyz+zip":
                    return AssetType.ApplicationXAsciiXyzZip;
                case "image/tiff; application=geotiff; profile=cloud-optimized":
                    return AssetType.ImageTiffApplicationGeotiffProfileCloudOptimized;
            }
            throw new Exception("Cannot unmarshal type AssetType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AssetType)untypedValue;
            switch (value)
            {
                case AssetType.ApplicationXAsciiXyzZip:
                    serializer.Serialize(writer, "application/x.ascii-xyz+zip");
                    return;
                case AssetType.ImageTiffApplicationGeotiffProfileCloudOptimized:
                    serializer.Serialize(writer, "image/tiff; application=geotiff; profile=cloud-optimized");
                    return;
            }
            throw new Exception("Cannot marshal type AssetType");
        }

        public static readonly AssetTypeConverter Singleton = new AssetTypeConverter();
    }

    internal class CollectionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Collection) || t == typeof(Collection?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "ch.swisstopo.swissalti3d")
            {
                return Collection.ChSwisstopoSwissalti3D;
            }
            throw new Exception("Cannot unmarshal type Collection");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Collection)untypedValue;
            if (value == Collection.ChSwisstopoSwissalti3D)
            {
                serializer.Serialize(writer, "ch.swisstopo.swissalti3d");
                return;
            }
            throw new Exception("Cannot marshal type Collection");
        }

        public static readonly CollectionConverter Singleton = new CollectionConverter();
    }

    internal class GeometryTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(GeometryType) || t == typeof(GeometryType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Polygon")
            {
                return GeometryType.Polygon;
            }
            throw new Exception("Cannot unmarshal type GeometryType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (GeometryType)untypedValue;
            if (value == GeometryType.Polygon)
            {
                serializer.Serialize(writer, "Polygon");
                return;
            }
            throw new Exception("Cannot marshal type GeometryType");
        }

        public static readonly GeometryTypeConverter Singleton = new GeometryTypeConverter();
    }

    internal class RelConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Rel) || t == typeof(Rel?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "collection":
                    return Rel.Collection;
                case "next":
                    return Rel.Next;
                case "previous":
                    return Rel.Previous;
                case "parent":
                    return Rel.Parent;
                case "root":
                    return Rel.Root;
                case "self":
                    return Rel.Self;
            }
            throw new Exception("Cannot unmarshal type Rel");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Rel)untypedValue;
            switch (value)
            {
                case Rel.Collection:
                    serializer.Serialize(writer, "collection");
                    return;
                case Rel.Next:
                    serializer.Serialize(writer, "next");
                    return;
                case Rel.Parent:
                    serializer.Serialize(writer, "parent");
                    return;
                case Rel.Root:
                    serializer.Serialize(writer, "root");
                    return;
                case Rel.Self:
                    serializer.Serialize(writer, "self");
                    return;
            }
            throw new Exception("Cannot marshal type Rel");
        }

        public static readonly RelConverter Singleton = new RelConverter();
    }

    internal class StacVersionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(StacVersion) || t == typeof(StacVersion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "0.9.0")
            {
                return StacVersion.The090;
            }
            throw new Exception("Cannot unmarshal type StacVersion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (StacVersion)untypedValue;
            if (value == StacVersion.The090)
            {
                serializer.Serialize(writer, "0.9.0");
                return;
            }
            throw new Exception("Cannot marshal type StacVersion");
        }

        public static readonly StacVersionConverter Singleton = new StacVersionConverter();
    }

    internal class FeatureTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FeatureType) || t == typeof(FeatureType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Feature")
            {
                return FeatureType.Feature;
            }
            throw new Exception("Cannot unmarshal type FeatureType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FeatureType)untypedValue;
            if (value == FeatureType.Feature)
            {
                serializer.Serialize(writer, "Feature");
                return;
            }
            throw new Exception("Cannot marshal type FeatureType");
        }

        public static readonly FeatureTypeConverter Singleton = new FeatureTypeConverter();
    }



}


